schema {
  query: Query
  mutation: Mutation
}

interface CreatePersonalAccessTokenError implements Error {
  message: String!
}

interface Error {
  message: String!
}

interface IResource {
  id: Uuid!
  title: String!
  version: ResourceVersion!
}

type AddApiSecretPayload {
  apiResource: ApiResource!
  secret: String!
}

type AddClientSecretPayload {
  client: Client
  secret: String
}

type AddSecretPersonalAccessTokenPayload {
  secret: String
  token: PersonalAccessToken
}

type ApiResource implements IResource {
  allowedAccessTokenSigningAlgorithms: [String!]!
  apiSecrets: [Secret!]!
  description: String
  displayName: String
  enabled: Boolean!
  id: Uuid!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  name: String!
  properties: [KeyValuePairOfStringAndString!]!
  requireResourceIndicator: Boolean!
  scopes: [ApiScope!]!
  tenant: String!
  tenantInfo: Tenant!
  title: String!
  userClaims: [String!]
  version: ResourceVersion!
}

type ApiScope implements IResource {
  description: String
  displayName: String
  enabled: Boolean!
  id: Uuid!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  name: String!
  properties: [KeyValuePairOfStringAndString!]!
  showInDiscoveryDocument: Boolean!
  tenant: String!
  tenantInfo: Tenant!
  title: String!
  userClaims: [String!]
  version: ResourceVersion!
}

type Application implements IResource {
  allowedGrantTypes: [String!]!
  apiScopes: [Uuid!]!
  clientIds: [Uuid!]!
  clients: [Client!]!
  id: Uuid!
  identityScopes: [Uuid!]!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  name: String!
  postLogoutRedirectUris: [String!]!
  redirectUris: [String!]!
  template: ClientTemplate!
  templateId: Uuid!
  tenant: String!
  tenantInfo: Tenant!
  title: String!
  userClaimRules: [UserClaimRule!]!
  version: ResourceVersion!
}

type ApproveResourcesResult {
  resources: [Uuid!]!
}

type ClaimRuleMatch {
  claimType: String!
  environmentId: Uuid
  matchMode: ClaimRuleMatchMode!
  value: String!
}

type Client implements IResource {
  absoluteRefreshTokenLifetime: Int!
  accessTokenLifetime: Int!
  accessTokenType: AccessTokenType!
  allowAccessTokensViaBrowser: Boolean!
  allowOfflineAccess: Boolean!
  allowPlainTextPkce: Boolean!
  allowRememberConsent: Boolean!
  allowedCorsOrigins: [String!]!
  allowedGrantTypes: [String!]
  allowedIdentityTokenSigningAlgorithms: [String!]!
  allowedScopes: [ClientScope!]!
  alwaysIncludeUserClaimsInIdToken: Boolean!
  alwaysSendClientClaims: Boolean!
  apiScopes: [Uuid!]
  application: Application
  authorizationCodeLifetime: Int!
  backChannelLogoutSessionRequired: Boolean!
  backChannelLogoutUri: String
  claims: [ClientClaim!]!
  clientClaimsPrefix: String
  clientDependencies: ClientDependencies!
  clientId: String!
  clientSecrets: [Secret!]
  clientUri: String
  consentLifetime: Int
  dataConnectors: [DataConnectorOptions!]
  dependencies: [IResource!]!
  description: String
  deviceCodeLifetime: Int!
  enableLocalLogin: Boolean!
  enabled: Boolean!
  enabledProviders: [EnabledProvider!]
  environmentIds: [Uuid!]!
  environments: [Uuid!]!
  frontChannelLogoutSessionRequired: Boolean!
  frontChannelLogoutUri: String
  id: Uuid!
  identityProviderRestrictions: [String!]!
  identityScopes: [Uuid!]
  identityTokenLifetime: Int!
  includeJwtId: Boolean!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  logoUri: String
  name: String!
  pairWiseSubjectSalt: String
  postLogoutRedirectUris: [String!]!
  properties: [KeyValuePairOfStringAndString!]
  protocolType: String
  redirectUris: [String!]!
  refreshTokenExpiration: TokenExpiration!
  refreshTokenUsage: TokenUsage!
  requireClientSecret: Boolean!
  requireConsent: Boolean!
  requirePkce: Boolean!
  requireRequestObject: Boolean!
  slidingRefreshTokenLifetime: Int!
  tenant: String!
  tenantInfo: Tenant!
  title: String!
  updateAccessTokenClaimsOnRefresh: Boolean!
  userCodeType: String
  userSsoLifetime: Int
  version: ResourceVersion!
}

type ClientClaim {
  type: String!
  value: String!
  valueType: String!
}

type ClientDependencies {
  apiResources: [ApiResource!]
  apiScopes: [ApiScope!]
  identityResources: [IdentityResource!]
}

type ClientScope {
  id: Uuid!
  type: ScopeType!
}

type ClientTemplate {
  allowAccessTokensViaBrowser: Boolean!
  allowOfflineAccess: Boolean!
  allowedGrantTypes: [String!]!
  apiScopes: [Uuid!]!
  clientIdGenerator: String
  dataConnectors: [DataConnectorOptions!]
  enabledProviders: [EnabledProvider!]
  id: Uuid!
  identityScopes: [Uuid!]!
  name: String!
  nameTemplate: String
  postLogoutRedirectUris: [String!]!
  redirectUris: [String!]!
  requireClientSecret: Boolean!
  requirePkce: Boolean!
  secretGenerator: String
  secrets: [ClientTemplateSecret!]!
  tenant: String!
  tenantInfo: Tenant!
  urlTemplate: String
}

type ClientTemplateSecret {
  environment: String!
  environmentId: Uuid!
  type: String
  value: String
}

type CreateApplicationPayload {
  application: Application
  clients: [CreatedClientInfo!]!
}

type CreatePersonalAccessTokenPayload {
  errors: [CreatePersonalAccessTokenError!]!
  token: PersonalAccessToken
}

type CreatedClientInfo {
  clientId: String!
  id: Uuid!
  name: String!
  secretValue: String
}

type DataConnectorOptions {
  enabled: Boolean!
  name: String
  profileTypeFilter: [ConnectorProfileType!]
  properties: [DataConnectorProperty!]
}

type DataConnectorProperty {
  name: String
  value: String
}

type Dependency {
  apiResources: [ApiResource!]
  apiScopes: [ApiScope!]
  identityResources: [IdentityResource!]
}

type EnabledProvider {
  name: String!
  requestMfa: Boolean!
  userIdClaimType: String
}

type Environment {
  id: Uuid!
  name: String!
  order: Int!
}

type ExpiresAtWasInThePast implements Error & CreatePersonalAccessTokenError {
  expiresAt: DateTime!
  message: String!
}

type GrantType {
  id: String!
  isCustom: Boolean!
  name: String!
  tenants: [String!]!
}

type HashAlgorithm {
  name: String!
}

type HashAlgorithmNotFound implements Error & CreatePersonalAccessTokenError {
  hashAlgorithm: String!
  message: String!
}

type HashedToken {
  createdAt: DateTime!
  expiresAt: DateTime!
  id: Uuid!
  token: String!
}

type IdOpsClaimExtension {
  type: String!
  value: String!
}

type IdentityResource implements IResource {
  description: String
  displayName: String
  emphasize: Boolean!
  enabled: Boolean!
  id: Uuid!
  identityServerGroup: IdentityServerGroup!
  identityServerGroupId: Uuid!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  name: String!
  properties: [KeyValuePairOfStringAndString!]!
  required: Boolean!
  showInDiscoveryDocument: Boolean!
  tenants: [String!]!
  title: String!
  userClaims: [String!]
  version: ResourceVersion!
}

type IdentityServer implements IResource {
  discoveryDocument: String!
  environmentId: Uuid!
  group: IdentityServerGroup!
  groupId: Uuid!
  id: Uuid!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  keys: [IdentityServerKey!]!
  name: String!
  title: String!
  url: String!
  version: ResourceVersion!
}

type IdentityServerEvent {
  activityId: String
  category: String
  clientId: String
  data: [KeyValuePairOfStringAndObject!]
  endpoint: String
  environmentName: String!
  eventId: Int!
  eventType: String
  hostname: String!
  id: Uuid!
  localIpAddress: String
  message: String
  name: String!
  processId: Int!
  rawData: String!
  remoteIpAddress: String
  serverGroupName: String!
  subjectId: String
  timeStamp: DateTime!
  type: String!
}

type IdentityServerGroup {
  color: String
  id: Uuid!
  name: String!
  tenants: [String!]!
}

type IdentityServerKey {
  alg: String!
  kid: String!
  serialNumber: String
  subject: String
  thumbprint: String
  validUntil: DateTime
}

type KeyValuePairOfStringAndObject {
  key: String!
}

type KeyValuePairOfStringAndString {
  key: String!
  value: String!
}

type Mutation @authorize(apply: BEFORE_RESOLVER, policy: "ApiAccessPolicy") {
  addApiSecret(input: AddApiSecretInput!): AddApiSecretPayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  addClientSecret(input: AddClientSecretInput!): AddClientSecretPayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  addClientToApplication(input: AddClientInput!): UpdateApplicationPayload!
  addEnvironmentToApplication(input: AddEnvironmentToApplicationInput!): UpdateApplicationPayload!
  addSecretToPersonalAccessToken(input: AddSecretPersonalAccessTokenInput!): AddSecretPersonalAccessTokenPayload! @authorize(apply: BEFORE_RESOLVER, policy: "PersonalAccessTokenEdit")
  approveResources(input: ApproveResourcesInput!): ApproveResourcesResult! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceApproval")
  createApplication(input: CreateApplicationInput!): CreateApplicationPayload!
  createClient(input: CreateClientInput!): SaveClientPayload! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  createPersonalAccessToken(input: CreatePersonalAccessTokenInput!): CreatePersonalAccessTokenPayload! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "PersonalAccessTokenEdit")
  publishResource(input: PublishResourceInput!): PublishResourcePayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringPublish")
  removeApiSecret(input: RemoveApiSecretInput!): SaveApiResourcePayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  removeClientFromApplication(input: RemoveClientInput!): UpdateApplicationPayload!
  removeClientSecret(input: RemoveClientSecretInput!): SaveClientPayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  removeSecretOfPersonalAccessToken(input: RemoveSecretPersonalAccessTokenInput!): RemoveSecretPersonalAccessTokenPayload! @authorize(apply: BEFORE_RESOLVER, policy: "PersonalAccessTokenEdit")
  saveApiResource(input: SaveApiResourceInput!): SaveApiResourcePayload! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  saveApiScope(input: SaveApiScopeInput!): SaveApiScopePayload! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  saveClientTemplate(input: SaveClientTemplateInput!): SaveClientTemplatePayload! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  saveEnvironment(input: SaveEnvironmentInput!): SaveEnvironmentPayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  saveGrantType(input: SaveGrantTypeInput!): SaveGrantTypePayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  saveIdentityResource(input: SaveIdentityResourceInput!): SaveIdentityResourcePayload! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  saveIdentityServer(input: SaveIdentityServerInput!): SaveIdentityServerPayload! @authorize(apply: BEFORE_RESOLVER, policy: "IdentityServerManage")
  saveIdentityServerGroup(input: SaveIdentityServerGroupInput!): SaveIdentityServerGroupPayload! @authorize(apply: BEFORE_RESOLVER, policy: "IdentityServerManage")
  saveTenant(input: SaveTenantInput!): SaveTenantPayload! @authorize(apply: BEFORE_RESOLVER, policy: "TenantManage")
  saveUserClaimRule(input: SaveUserClaimRuleInput!): SaveUserClaimRulePayload! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  updateApplication(input: UpdateApplicationInput!): UpdateApplicationPayload!
  updateClient(input: UpdateClientInput!): SaveClientPayload! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringEdit")
  updatePersonalAccessToken(input: UpdatePersonalAccessTokenInput!): SavePersonalAccessTokenPayload! @authorize(apply: BEFORE_RESOLVER, policy: "PersonalAccessTokenEdit")
}

type PersonalAccessToken implements IResource {
  allowedApplicationIds: [Uuid!]!
  allowedScopes: [String!]!
  applications: [Application!]!
  claimsExtensions: [IdOpsClaimExtension!]!
  createdAt: DateTime!
  dependencies: [IResource!]!
  environmentId: Uuid!
  environmentIds: [Uuid!]!
  hashAlgorithm: String!
  id: Uuid!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  requiresApproval(id: Uuid!): Boolean!
  source: String!
  tenant: String!
  tenantInfo: Tenant!
  title: String!
  tokens: [HashedToken!]!
  userName: String!
  version: ResourceVersion!
}

type PublishResourcePayload {
  errors: [UserError!]
  jobId: Uuid!
  resources: [Uuid!]!
}

type PublishedResource {
  currentVersion: ResourceVersion!
  environments: [PublishedResourceEnvironment!]!
  id: Uuid!
  title: String!
  type: String!
}

type PublishedResourceEnvironment {
  environment: Environment!
  needsApproval: Boolean!
  publishedAt: DateTime
  state: String
  version: Int
}

type Query @authorize(apply: BEFORE_RESOLVER, policy: "ApiAccessPolicy") {
  apiResources(input: GetApiResourcesInput): [ApiResource!]! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  apiScopes(input: GetApiScopesInput): [ApiScope!]! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  application(id: Uuid!): Application!
  client(id: Uuid!): Client! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  clientIdGenerators: [String!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  clientTemplateById(id: Uuid!): ClientTemplate! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  clientTemplates: [ClientTemplate!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  dependencies(input: GetDependenciesInput!): Dependency! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  environments: [Environment!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  grantTypes: [GrantType!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  hashAlgorithms: [HashAlgorithm!]!
  identityResources(input: GetIdentityResourcesInput): [IdentityResource!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  identityServer(id: Uuid!): IdentityServer!
  identityServers: [IdentityServer!]!
  identityServersGroups: [IdentityServerGroup!]!
  me: User!
  personalAccessToken(id: Uuid!): PersonalAccessToken! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "PersonalAccessTokenRead")
  personalAccessTokens(input: GetPersonalAccessTokensInput!): [PersonalAccessToken!]! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "PersonalAccessTokenRead")
  publishedResouces(input: PublishedResourcesInput): [PublishedResource!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  resourceApprovals(input: ResourceApprovalInput): [ResourceApproval!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceApproval")
  searchApplications(input: SearchApplicationsInput!): SearchResultOfApplication!
  searchClients(input: SearchClientsInput!): SearchResultOfClient! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  searchIdentityServerEvents(input: SearchIdentityServerEventsInput!): SearchResultOfIdentityServerEvent!
  searchPersonalAccessTokens(input: SearchPersonalAccessTokensInput!): SearchResultOfPersonalAccessToken! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "PersonalAccessTokenRead")
  searchResourceAudits(input: SearchResourceAuditInput!): SearchResultOfResourceAuditEvent! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  searchUnMappedClients(tenant: String!): [Client!]!
  secrets: [ClientTemplateSecret!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  sharedSecretGenerators: [String!]! @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  tenants: [Tenant!]!
  userClaimsRule(id: Uuid!): UserClaimRule! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
  userClaimsRules(input: GetUserClaimRulesInput!): [UserClaimRule!]! @authorize(apply: AFTER_RESOLVER, policy: "TenantResourceAccess") @authorize(apply: BEFORE_RESOLVER, policy: "ResourceAuthoringRead")
}

type RemoveSecretPersonalAccessTokenPayload {
  hash: HashedToken
  token: PersonalAccessToken
}

type ResourceApproval {
  currentVersion: ResourceVersion!
  environments: [ResourceApprovalEnvironment!]!
  id: Uuid!
  title: String!
  type: String!
}

type ResourceApprovalEnvironment {
  approvedAt: DateTime
  environment: Environment!
  state: String
  version: Int
}

type ResourceAuditEvent {
  action: String!
  changes: [ResourceChange!]!
  id: Uuid!
  resourceId: Uuid!
  resourceType: String!
  timestamp: DateTime!
  userId: String!
  version: Int!
}

type ResourceChange {
  after: String
  arrayIndex: Int
  before: String
  delta: String
  path: String!
  property: String!
}

type ResourceVersion {
  createdAt: DateTime!
  createdBy: String!
  version: Int!
}

type SaveApiResourcePayload {
  apiResource: ApiResource
  errors: [UserError!]
}

type SaveApiScopePayload {
  apiScope: ApiScope
  errors: [UserError!]
}

type SaveClientPayload {
  client: Client
}

type SaveClientTemplatePayload {
  clientTemplate: ClientTemplate
}

type SaveEnvironmentPayload {
  environment: Environment!
  errors: [UserError!]
}

type SaveGrantTypePayload {
  errors: [UserError!]
  grantType: GrantType!
}

type SaveIdentityResourcePayload {
  errors: [UserError!]
  identityResource: IdentityResource
}

type SaveIdentityServerGroupPayload {
  serverGroup: IdentityServerGroup!
}

type SaveIdentityServerPayload {
  server: IdentityServer!
}

type SavePersonalAccessTokenPayload {
  token: PersonalAccessToken
}

type SaveTenantPayload {
  errors: [UserError!]
  tenant: Tenant!
}

type SaveUserClaimRulePayload {
  rule: UserClaimRule!
}

type SearchResultOfApplication {
  hasMore: Boolean!
  items: [Application!]!
  totalCount: Int!
}

type SearchResultOfClient {
  hasMore: Boolean!
  items: [Client!]!
  totalCount: Int!
}

type SearchResultOfIdentityServerEvent {
  hasMore: Boolean!
  items: [IdentityServerEvent!]!
  totalCount: Int!
}

type SearchResultOfPersonalAccessToken {
  hasMore: Boolean!
  items: [PersonalAccessToken!]!
  totalCount: Int!
}

type SearchResultOfResourceAuditEvent {
  hasMore: Boolean!
  items: [ResourceAuditEvent!]!
  totalCount: Int!
}

type Secret {
  description: String
  expiration: DateTime
  id: Uuid!
  type: String!
  value: String!
}

type Tenant {
  color: String
  description: String!
  emails: [String!]!
  id: String!
  modules: [TenantModule!]!
  roleMappings: [TenantRoleMapping!]!
}

type TenantModule {
  name: String!
  settings: [TenantSetting!]
}

type TenantRoleMapping {
  claimValue: String!
  environmentId: Uuid
  role: String!
}

type TenantSetting {
  name: String!
  value: String!
}

type UpdateApplicationPayload {
  application: Application
}

type User {
  id: String!
  name: String!
  permissions: [String!]!
  roles: [String!]!
}

type UserClaim {
  type: String!
  value: String!
}

type UserClaimRule implements IResource {
  applicationId: Uuid
  claims: [UserClaim!]!
  id: Uuid!
  isInServerGroup(serverGroup: IdentityServerGroupInput!): Boolean!
  name: String!
  rules: [ClaimRuleMatch!]!
  tenant: String!
  tenantInfo: Tenant!
  title: String!
  version: ResourceVersion!
}

type UserError {
  code: String!
  message: String!
}

input AddApiSecretInput {
  generator: String
  id: Uuid!
  name: String
  saveValue: Boolean
  value: String
}

input AddClientInput {
  clientId: Uuid!
  id: Uuid!
}

input AddClientSecretInput {
  generator: String
  id: Uuid!
  name: String
  saveValue: Boolean
  value: String
}

input AddEnvironmentToApplicationInput {
  environments: [Uuid!]!
  id: Uuid!
}

input AddSecretPersonalAccessTokenInput {
  expiresAt: DateTime!
  tokenId: Uuid!
}

input ApproveResourceInput {
  environmentId: Uuid!
  resourceId: Uuid!
  type: String!
  version: Int!
}

input ApproveResourcesInput {
  resources: [ApproveResourceInput!]!
}

input ClaimRuleMatchInput {
  claimType: String!
  environmentId: Uuid
  matchMode: ClaimRuleMatchMode!
  value: String!
}

input ClaimsExtensionRequestInput {
  type: String!
  value: String!
}

input ClientClaimInput {
  type: String!
  value: String!
  valueType: String!
}

input ClientPropertyInput {
  key: String!
  value: String!
}

input ClientTemplateSecretInput {
  environmentId: Uuid!
  type: String
  value: String
}

input CreateApplicationInput {
  allowedGrantTypes: [String!]!
  apiScopes: [Uuid!]!
  environments: [Uuid!]!
  identityScopes: [Uuid!]!
  name: String!
  redirectUris: [String!]!
  templateId: Uuid!
  tenant: String!
}

input CreateClientInput {
  allowedGrantTypes: [String!]!
  apiScopes: [Uuid!]!
  clientId: String
  clientIdGenerator: String
  environments: [Uuid!]!
  identityScopes: [Uuid!]!
  name: String!
  tenant: String!
}

input CreatePersonalAccessTokenInput {
  allowedApplicationIds: [Uuid!]!
  allowedScopes: [String!]!
  claimsExtensions: [ClaimsExtensionRequestInput!]!
  environmentId: Uuid!
  hashAlgorithm: String!
  source: String!
  tenant: String!
  userName: String!
}

input DataConnectorOptionsInput {
  enabled: Boolean!
  name: String
  profileTypeFilter: [ConnectorProfileType!]
  properties: [DataConnectorPropertyInput!]
}

input DataConnectorPropertyInput {
  name: String
  value: String
}

input EnabledProviderInput {
  name: String!
  requestMfa: Boolean!
  userIdClaimType: String
}

input GetApiResourcesInput {
  tenants: [String!]!
}

input GetApiScopesInput {
  tenants: [String!]!
}

input GetDependenciesInput {
  id: Uuid!
  type: String
}

input GetIdentityResourcesInput {
  tenants: [String!]!
}

input GetPersonalAccessTokensInput {
  tenants: [String!]!
}

input GetUserClaimRulesInput {
  tenants: [String!]!
}

input IdOpsClaimExtensionInput {
  type: String!
  value: String!
}

input IdentityServerGroupInput {
  color: String
  id: Uuid!
  name: String!
  tenants: [String!]!
}

input PublishResourceInput {
  destinationEnvionmentId: Uuid!
  resources: [Uuid!]!
}

input PublishedResourcesInput {
  environment: Uuid
  identityServerGroupId: Uuid
  resourceId: [Uuid!]
  resourceTypes: [String!]
  tenants: [String!]!
}

input RemoveApiSecretInput {
  apiResourceId: Uuid!
  id: Uuid!
}

input RemoveClientInput {
  clientId: Uuid!
  id: Uuid!
}

input RemoveClientSecretInput {
  clientId: Uuid!
  id: Uuid!
}

input RemoveSecretPersonalAccessTokenInput {
  secretId: Uuid!
  tokenId: Uuid!
}

input ResourceApprovalInput {
  environmentId: Uuid
  identityServerGroupId: Uuid
  resourceIds: [Uuid!]
  resourceTypes: [String!]
  tenants: [String!]
}

input SaveApiResourceInput {
  description: String
  displayName: String
  enabled: Boolean!
  id: Uuid
  name: String!
  scopes: [Uuid!]!
  tenant: String!
}

input SaveApiScopeInput {
  description: String
  displayName: String!
  enabled: Boolean!
  id: Uuid
  name: String!
  showInDiscoveryDocument: Boolean!
  tenant: String!
}

input SaveClientTemplateInput {
  allowAccessTokensViaBrowser: Boolean!
  allowOfflineAccess: Boolean!
  allowedGrantTypes: [String!]!
  apiScopes: [Uuid!]
  clientIdGenerator: String
  dataConnectors: [DataConnectorOptionsInput!]
  enabledProviders: [EnabledProviderInput!]
  id: Uuid
  identityScopes: [Uuid!]
  name: String!
  nameTemplate: String
  postLogoutRedirectUris: [String!]
  redirectUris: [String!]
  requireClientSecret: Boolean!
  requirePkce: Boolean!
  secretGenerator: String
  secrets: [ClientTemplateSecretInput!]!
  tenant: String!
  urlTemplate: String
}

input SaveEnvironmentInput {
  id: Uuid
  name: String!
  order: Int!
}

input SaveGrantTypeInput {
  id: String!
  isCustom: Boolean!
  name: String!
  tenants: [String!]!
}

input SaveIdentityResourceInput {
  description: String
  displayName: String!
  emphasize: Boolean!
  enabled: Boolean!
  id: Uuid
  identityServerGroupId: Uuid!
  name: String!
  required: Boolean!
  showInDiscoveryDocument: Boolean!
  tenants: [String!]!
  userClaims: [String!]!
}

input SaveIdentityServerGroupInput {
  color: String!
  id: Uuid
  name: String!
  tenants: [String!]!
}

input SaveIdentityServerInput {
  environmentId: Uuid!
  groupId: Uuid!
  id: Uuid
  name: String!
  url: String!
}

input SaveTenantInput {
  color: String!
  description: String!
  emails: [String!]
  id: String!
  modules: [TenantModuleInput!]
  roleMappings: [TenantRoleMappingInput!]
}

input SaveUserClaimRuleInput {
  applicationId: Uuid
  claims: [UserClaimInput!]!
  id: Uuid
  name: String!
  rules: [ClaimRuleMatchInput!]!
  tenant: String!
}

input SearchApplicationsInput {
  pageNr: Int!
  pageSize: Int!
  searchText: String
  tenants: [String!]!
}

input SearchClientsInput {
  environmentId: Uuid
  pageNr: Int!
  pageSize: Int!
  searchText: String
  tenants: [String!]
}

input SearchIdentityServerEventsInput {
  clientId: String
  environment: String
  eventTypes: [String!]
  pageNr: Int!
  pageSize: Int!
}

input SearchPersonalAccessTokensInput {
  environmentId: Uuid
  pageNr: Int!
  pageSize: Int!
  searchText: String
  tenants: [String!]
}

input SearchResourceApprovalLogsInput {
  environmentId: Uuid
  pageNr: Int!
  pageSize: Int!
  resourceId: Uuid
}

input SearchResourceAuditInput {
  pageNr: Int!
  pageSize: Int!
  resourceId: Uuid
  userId: String
}

input TenantModuleInput {
  name: String!
  settings: [TenantSettingInput!]
}

input TenantRoleMappingInput {
  claimValue: String!
  environmentId: Uuid
  role: String!
}

input TenantSettingInput {
  name: String!
  value: String!
}

input UpdateApplicationInput {
  allowedGrantTypes: [String!]!
  apiScopes: [Uuid!]!
  id: Uuid!
  identityScopes: [Uuid!]!
  name: String!
  redirectUris: [String!]!
}

input UpdateClientInput {
  absoluteRefreshTokenLifetime: Int!
  accessTokenLifetime: Int!
  accessTokenType: AccessTokenType!
  allowAccessTokensViaBrowser: Boolean!
  allowOfflineAccess: Boolean!
  allowPlainTextPkce: Boolean!
  allowRememberConsent: Boolean!
  allowedCorsOrigins: [String!]!
  allowedGrantTypes: [String!]!
  allowedIdentityTokenSigningAlgorithms: [String!]!
  alwaysIncludeUserClaimsInIdToken: Boolean!
  alwaysSendClientClaims: Boolean!
  apiScopes: [Uuid!]!
  authorizationCodeLifetime: Int!
  backChannelLogoutSessionRequired: Boolean!
  backChannelLogoutUri: String
  claims: [ClientClaimInput!]
  clientClaimsPrefix: String
  clientUri: String
  consentLifetime: Int
  dataConnectors: [DataConnectorOptionsInput!]
  description: String
  deviceCodeLifetime: Int!
  enabledProviders: [EnabledProviderInput!]
  environments: [Uuid!]!
  frontChannelLogoutSessionRequired: Boolean!
  frontChannelLogoutUri: String
  id: Uuid!
  identityScopes: [Uuid!]!
  identityTokenLifetime: Int!
  logoUri: String
  name: String!
  pairWiseSubjectSalt: String
  postLogoutRedirectUris: [String!]!
  properties: [ClientPropertyInput!]
  protocolType: String
  redirectUris: [String!]!
  refreshTokenExpiration: TokenExpiration!
  refreshTokenUsage: TokenUsage!
  requireClientSecret: Boolean!
  requireConsent: Boolean!
  requirePkce: Boolean!
  requireRequestObject: Boolean!
  slidingRefreshTokenLifetime: Int!
  tenant: String!
  updateAccessTokenClaimsOnRefresh: Boolean!
  userCodeType: String
  userSsoLifetime: Int
}

input UpdatePersonalAccessTokenInput {
  allowedApplicationIds: [Uuid!]
  allowedScopes: [String!]
  claimsExtensions: [IdOpsClaimExtensionInput!]
  id: Uuid!
  source: String
  userName: String
}

input UserClaimInput {
  type: String!
  value: String!
}

enum AccessTokenType {
  JWT
  REFERENCE
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum ClaimRuleMatchMode {
  EQUALS
  CONTAINS
  START_WITH
  ENDS_WITH
  ONE_OF
  REGEX
}

enum ConnectorProfileType {
  USER_INFO
  ACCESS_TOKEN
  IDENTITY_TOKEN
}

enum ScopeType {
  IDENTITY
  RESOURCE
}

enum TokenExpiration {
  SLIDING
  ABSOLUTE
}

enum TokenUsage {
  RE_USE
  ONE_TIME_ONLY
}

directive @authorize("Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER "The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!]) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("Deferred when true." if: Boolean "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("Streamed when true." if: Boolean "The initial elements that shall be send down to the consumer." initialCount: Int! "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String) on FIELD

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

scalar Uuid
